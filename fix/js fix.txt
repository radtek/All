1.
精简switch
写法1：
var add_step = 12;
var add_level={'5':1,'10':2,'12':3,'15':4}[add_step] || 0;
写法2：
var add_level = (add_step>12 && 4) || (add_step>10 && 3) || (add_step>5 && 2) || (add_step>0 && 1) || 0; 
利用短路原理 add_step 13  (1 && 4)则为 4，不会继续往下走了 


2.打印js数组在 连接字符串和不连接字符串下的两种情况
function A(){
    this.a = 1;
}

function B(){
	this.obj_1 = new A();
	this.obj_2 = new A();
	this.obj_3 = new A();
	this.arr = [];
	this.arr.push(this.obj_1);
	this.arr.push(this.obj_2);
	this.arr.push(this.obj_3);

    console.log(this.arr);
	console.log("this.arr----->"+this.arr);

	for (var i in this.arr){
		console.log(i+","+this.arr[i].constructor.name+','+typeof(this.arr[i]));
		console.log(this.arr[i] instanceof A);
	}
}

var b = new B();

###output:
[A, A, A]
Script snippet #1:24 this.arr----->[object Object],[object Object],[object Object]
Script snippet #1:27 0,A,object
Script snippet #1:28 true
Script snippet #1:27 1,A,object
Script snippet #1:28 true
Script snippet #1:27 2,A,object
Script snippet #1:28 true

2.原型链继承和 调用父类带参函数call(this,num1,num2)

var Base =
{
    _object: function (o)
    {
        function F() {}
        F.prototype = o;
        return new F();
    },

    inheritPrototype: function (subType, superType)
    {
        var f = this._object(superType.prototype);??//创建对象
        f.constructor = subType;                    //增强对象
        subType.prototype = f;                      //指定对象
    }
};


function ClassA(){
	if (ClassA._initialized === undefined)
	{
		ClassA.prototype.AddNum = function(num1,num2)
		{
			console.log("sum--->"+(num1+num2));
		}

		ClassA._initialized = true;
	}
}

function ClassB(){

	ClassA.call(this);
	if(ClassB._initialized === undefined){

		ClassB.prototype.AddNum = function(num1,num2)
		{
			ClassA.prototype.AddNum.call(this,num1,num2);
			console.log("diff--->"+(num1-num2));
		}

		ClassB._initialized = true;
	}
}
Base.inheritPrototype(ClassB,ClassA);

var vb = new ClassB();
vb.AddNum(3,1);
console.log("test");
